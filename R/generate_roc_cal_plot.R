#' @title Generate ROC and Calibration Plots for Survival Risk Model
#'
#' @description
#' This function calculates a risk score (linear predictor) from a pre-fitted Cox
#' Proportional Hazards model, performs time-dependent ROC analysis and calibration,
#' finds an optimal cutpoint, and calculates diagnostic metrics.
#'
#' @param data A data frame containing the survival data and predictors for which
#'   the risk scores should be calculated (e.g., the validation/test set).
#' @param coxph_model An object of class \code{\link[survival]{coxph}} that has
#'   already been fitted. This model is used to calculate the risk score.
#' @param time_col A character string representing the name of the time-to-event column in \code{data}.
#' @param event_col A character string representing the name of the event/status column in \code{data} (1=event, 0=censor).
#' @param survC_type A character string for the 'type' argument in \code{survC::calc_risk_score()}.
#'   Default is "risk".
#' @param tdroc_t The required time point 't' (numeric) for time-dependent ROC analysis
#'   using \code{survC::tdroc_calc()}. This time point is also used to define the binary
#'   outcome for cutpoint and confusion matrix calculation.
#' @param cutpointr_method The method used to select the optimal cutpoint in \code{\link[cutpointr]{cutpointr}}.
#'   Default is \code{maximize_metric}.
#' @param cutpointr_metric The metric to be optimized in \code{\link[cutpointr]{cutpointr}}.
#'   Default is \code{youden}.
#' @param cutpointr_boots The number of bootstrap runs for \code{\link[cutpointr]{cutpointr}}.
#'   Default is 1000. Set to 0 for no bootstrapping.
#' @param roc_title A character string for the title of the ROC curve plot.
#' @param cal_title A character string for the title of the calibration plot.
#' @param merged_title A character string for the overall title of the merged plot.
#'
#' @return A list containing the following outputs:
#' \item{AUC}{The time-dependent Area Under the Curve (AUC) value at time \code{tdroc_t}.}
#' \item{Optimal_Cutpoint}{The optimal risk score cutpoint determined by \code{cutpointr}.}
#' \item{ROC_Curve}{The time-dependent ROC curve generated by \code{survC::tdroc_plot}.}
#' \item{Calibration_Plot}{The calibration plot generated by \code{survC::cal_plot}.}
#' \item{Merged_Plot}{A combined plot of the ROC Curve and Calibration Plot (using \code{cowplot}).}
#' \item{Confusion_Matrix}{The output of \code{caret::confusionMatrix} using the optimal cutpoint
#'   to classify outcomes at time \code{tdroc_t}.}
#' \item{Wilson_CI_Output}{A formatted character string reporting the mean proportion correctly
#'   diagnosed with a one-sided 95% Wilson Confidence Interval.}
#'
generate_roc_cal_plot <- function(
    data,
    coxph_model, 
    time_col,    
    event_col,   
    survC_type = "risk", 
    tdroc_t,             
    cutpointr_method = maximize_metric, 
    cutpointr_metric = youden,          
    cutpointr_boots = 1000,             
    roc_title = "Time-Dependent ROC Curve",
    cal_title = "Calibration Plot",
    merged_title = "ROC and Calibration Merged Plot"
) {
  
  # --- 1. Calculate Risk Score and Add to Data Frame ---
  # The call to calc_risk_score with a model object returns a numeric vector.
  risk_score_vector <- survC::calc_risk_score(
    model = coxph_model, 
    data = data,
    type = survC_type 
  )
  
  data$risk_score <- risk_score_vector
  
  # --- 2. Manually Construct List for survC::tdroc_calc and survC::cal_plot ---
  # These functions require a list containing time, event, and the score.
  risk_score_result_list <- list(
    time = data[[time_col]],
    event = data[[event_col]],
    risk_score = data$risk_score
  )
  
  # --- 3. Calculate AUC and ROC Curve ---
  tdroc_res <- survC::tdroc_calc(
    risk_score_result_list, 
    t = tdroc_t, 
    plot = FALSE
  )
  
  roc_plot <- survC::tdroc_plot(
    tdroc_res,
    t = tdroc_t,
    title = roc_title
  )
  
  # --- 4. Calibration Plot ---
  cal_res <- survC::cal_plot(risk_score_result_list)
  cal_plot <- cal_res$plot + labs(title = cal_title)
  
  # --- 5. Find Optimal Cutpoint (cp) ---
  time_data <- data[[time_col]]
  event_data <- data[[event_col]]
  
  data$outcome_at_t <- ifelse(time_data <= tdroc_t & event_data == 1, 1, 0)
  
  cp <- cutpointr(
    x = data$risk_score, 
    class = data$outcome_at_t, 
    pos_class = 1, 
    neg_class = 0,
    method = cutpointr_method, 
    metric = cutpointr_metric, 
    boot = cutpointr_boots       
  )
  
  optimal_cutpoint <- cp$optimal_cutpoint[1]
  
  # --- 6. Confusion Matrix and Diagnostic Performance ---
  data$prediction <- as.factor(
    ifelse(data$risk_score > optimal_cutpoint, "Positive", "Negative")
  )
  
  data$true_class <- as.factor(
    ifelse(data$outcome_at_t == 1, "Positive", "Negative")
  )
  
  data$prediction <- relevel(data$prediction, ref = "Negative")
  data$true_class <- relevel(data$true_class, ref = "Negative")
  
  conf_matrix <- caret::confusionMatrix(data$prediction, data$true_class)
  
  # Calculate diagnostic accuracy using Wilson's interval
  wilson_res <- cutpointr::wilson_ci(
    tp = conf_matrix$table["Positive", "Positive"],
    fp = conf_matrix$table["Positive", "Negative"],
    fn = conf_matrix$table["Negative", "Positive"],
    tn = conf_matrix$table["Negative", "Negative"]
  )
  
  # --- 7. Merged Plot ---
  merged_plot <- cowplot::plot_grid(
    roc_plot, cal_plot, 
    labels = c("A", "B"), ncol = 2,
    rel_widths = c(1, 1)
  )
  merged_plot <- cowplot::plot_grid(
    ggplot() + labs(title = merged_title) + theme_void(),
    merged_plot,
    ncol = 1, rel_heights = c(0.05, 1)
  )
  
  # --- 8. Prepare Output ---
  wilson_output_string <- paste0(
    "Mean proportion correctly diagnosed = ", round(wilson_res$mean, 2), ", ",
    "one-sided 95% CI (", round(wilson_res$lower, 2), " - ",  
    round(wilson_res$upper, 2), ")"
  )
  
  return(list(
    AUC = tdroc_res$auc,
    Optimal_Cutpoint = optimal_cutpoint,
    ROC_Curve = roc_plot,
    Calibration_Plot = cal_plot,
    Merged_Plot = merged_plot,
    Confusion_Matrix = conf_matrix,
    Wilson_CI_Output = wilson_output_string
  ))
}