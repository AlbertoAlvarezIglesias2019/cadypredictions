#' Calculate Area Under the Curve (AUC) and Classification Metrics
#'
#' This function systematically calculates the AUC, its confidence intervals,
#' and optimal classification metrics (Sensitivity, Specificity, PPV, NPV)
#' for risk predictions generated by Partly Conditional (PC) and Time-Dependent (TD)
#' Cox models across a user-defined set of clinical endpoints and biomarkers. It
#' performs analyses for both unadjusted and adjusted models, where the adjusted
#' models incorporate a customizable set of covariates.
#'
#' @param dir_in A character string specifying the path to the directory
#'   where the input CSV data files are located. Defaults to a specific network
#'   path. Requires files like \code{cady_data_ct.csv} and \code{baseline_data.csv}.
#' @param dir_out A character string specifying the path to the directory
#'   where the final results (\code{RESULTS_AUC.RData} and \code{RESULTS_AUC.csv})
#'   should be saved. Defaults to a specific network path.
#' @param dat_nam A character vector listing the base names of the data files
#'   representing different clinical endpoint definitions (e.g., \code{c("cady_data_ct", "cady_data_drug", ...)}).
#' @param mar_nam A character vector listing the biomarker names to analyze
#'   (e.g., \code{c("BNP", "NT_pro_BNP", ...)}).
#' @param predictores A character vector specifying the names of the covariates
#'   to be included in the 'Adjusted' models. These variables must be present
#'   in the \code{baseline_data.csv} file. Defaults to a predefined set of six covariates.
#'
#' @return The function does not explicitly return a value but saves the
#'   aggregated results as an RData file and a CSV file named \code{RESULTS_AUC.RData}
#'   and \code{RESULTS_AUC.csv} in the directory specified by \code{dir_out}.
#'   The saved data frame includes AUC, Bonferroni-corrected and uncorrected
#'   95\% confidence intervals (CIs), optimal threshold metrics (Sensitivity, Specificity, PPV, NPV),
#'   and the optimal threshold value.
#'
#' @details
#' The function generates a grid of all combinations of \code{dat_nam} and \code{mar_nam}.
#' For each combination, it loads the data, merges it with baseline covariates, and fits
#' four distinct survival models using \code{\link[cadypredictions]{predict_risk}}:
#'
#' \enumerate{
#'   \item **Unadjusted PC** and **Unadjusted TD Cox**: Biomarker only.
#'   \item **Adjusted PC** and **Adjusted TD Cox**: Biomarker plus the covariates specified in **`predictores`**.
#' }
#'
#' For each of the four models, performance metrics are calculated:
#'
#' * **Multiple Comparison Correction:** A Bonferroni-corrected confidence level ($\text{bc}$) is calculated
#'     based on the total number of models ($|\text{dat\_nam}| \times |\text{mar\_nam}| \times 4$ total tests).
#' * **AUC & CI Calculation:** The Area Under the Curve (AUC) is computed. Confidence intervals (CIs) are calculated
#'     using the **DeLong method** , providing both the Bonferroni-corrected CI (\code{LB}, \code{UB})
#'     and the standard 95\% CI (\code{LB\_nobon}, \code{UB\_nobon}).
#' * **Optimal Threshold & Metrics:** The optimal risk threshold is identified using **Youden's J statistic**
#'     (\code{best.method = "youden"}). At this threshold, Sensitivity, Specificity, PPV, and NPV are extracted.
#' * **Threshold Type:** The optimal threshold is reported either as the predicted **probability** (\code{Prob}) or
#'     the corresponding log-transformed **biomarker value** (\code{Marker}).
#'
#' @import cadypredictions
#' @import tidyverse
#' @import partlyconditional
#' @import survival
#' @import pROC
#' @importFrom base paste read.csv data.frame round
#' @importFrom dplyr select left_join arrange filter slice_tail
#' @importFrom pROC roc ci coords
#'
#' @seealso
#' The model fitting uses \code{\link[cadypredictions]{predict_risk}}.
#' The AUC and classification metrics rely heavily on the \code{pROC} package.
#'
#' @examples
#' \dontrun{
#' # Analyze BNP and CRP for a subset of endpoints, adjusting for only age and LVEF
#' custom_predictors <- c("Age", "lvef_mp_bas")
#' RESULTS_AUC(
#'   dir_in = "C:/data_location/",
#'   dir_out = "C:/results_location/",
#'   dat_nam = c("cady_data_ct", "cady_data_drug"),
#'   mar_nam = c("BNP", "CRP"),
#'   predictores = custom_predictors
#' )
#' # The results will be saved in "C:/results_location/RESULTS_AUC.csv"
#' }
#'
#' @export
#' 
#' 

RESULTS_AUC <- function(dir_in = "M:/CRF/ICORG/Studies/CADY/Clinical_Study_Report/Report/data/",
                    dir_out = "M:/CRF/ICORG/Studies/CADY/Clinical_Study_Report/Report/results/",
                    dat_nam = c("cady_data_ct","cady_data_drug","cady_data_max_50","cady_data_max_53","cady_data_mp_50","cady_data_mp_53"),
                    mar_nam = c("BNP","NT_pro_BNP","CRP","hsTnI_STAT","Galectin_3"),
                    predictores = c("Age","lvef_mp_bas","diabetes_mellitus_YN","hypertension_YN","dyslipidemia_YN","treatment_reg")){
  
  
  library(cadypredictions)
  library(tidyverse)
  library(partlyconditional)
  library(survival)
  library(pROC)
  
  pointer <- expand.grid(data_name = dat_nam,
                         marker_name = mar_nam)
  
  bc <- 1-0.05/(dim(pointer)[1]*4)
  
  
  temp <- lapply(1:dim(pointer)[1],function (kkk){
    #data_name <- "cady_data_mp_50"
    #marker_name = "NT_pro_BNP"
    data_name <- as.character(pointer$data_name[kkk])
    marker_name <- as.character(pointer$marker_name[kkk])
    
    #data_name <- "cady_data_max_50" 
    #marker_name <- "Galectin_3"
    
    cat("\n\n\n",data_name," and ",marker_name,"\n\n")  
    pa <- paste(dir_in,data_name,".csv",sep="")
    
    pa <- paste(dir_in,data_name,".csv",sep="")
    masterD <- read.csv(pa)
    n0 <- "SubjectID"
    n1 <- mar_nam
    n2 <- paste(mar_nam,"_bl",sep="")
    n3 <- c("lvef_mp_bas","lvef_max_bas","time_to_event","status","time_to_sample")
    n4 <- predictores
    wher <- names(masterD) %in% c(n0,n1,n2,n3,n4)
    masterD <- masterD[,wher]
    
    
    bldata <- read.csv(paste(dir_in,"baseline_data.csv",sep=""))
    wher1 <- names(bldata) %in% predictores
    wher2 <- names(bldata) %in% names(masterD)
    wher <- wher1 & !wher2
    bldata <- bldata[,c("SubjectID",names(bldata)[wher])]
    
    masterD <- masterD %>% left_join(bldata,by = "SubjectID")
    
    
    

    
    ###################
    ### Unadjusted PC
    ###################
    fit <- predict_risk(
      datos = masterD,
      marker_name = marker_name,
      log_marker = TRUE,
      pred_from = 150,
      pred_to = 240
    )
    
    df <- as.data.frame(fit$pred_data)
    
    # --- 2. ROC Calculation (pROC) ---
    what <- "Risk_PC"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out1 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Unadjusted",
                       model = "Partly conditional",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$pc_model_predictors,collapse="+"))
    
    
    ###################
    ### Unadjusted TD
    ###################
    df <- as.data.frame(fit$pred_data)
    
    # --- 2. ROC Calculation (pROC) ---
    what <- "Risk_TDcox"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out2 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Unadjusted",
                       model = "Time dependent Cox PH",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$tdcox_model_predictors,collapse="+"))
    
    
    ##########################
    ### Unadjusted Simple Cox
    ##########################
    df <- as.data.frame(fit$pred_data)
    
    # --- 2. ROC Calculation (pROC) ---
    what <- "Risk_cox_simple"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out3 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Unadjusted",
                       model = "Simple Cox PH",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$simplecox_model_predictors,collapse="+"))
    
    
    ################
    ### Adjusted PC
    ################
    fit <- predict_risk(
      datos = masterD,
      marker_name = marker_name,
      Predictors = predictores,
      log_marker = TRUE,
      pred_from = 150,
      pred_to = 240
    )
    pc_model_predictors<-fit$pc_model_predictors
    tdcox_model_predictors <- fit$tdcox_model_predictors
    simplecox_model_predictors <- fit$simplecox_model_predictors
    
    
    df <- as.data.frame(fit$pred_data)
    
    # --- 2. ROC Calculation (pROC) ---
    what = "Risk_PC"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out4 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Adjusted",
                       model = "Partly conditional",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$pc_model_predictors,collapse="+"))
    
    
    ###################
    ### Adjusted TD
    ###################
    # --- 2. ROC Calculation (pROC) ---
    what = "Risk_TDcox"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out5 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Adjusted",
                       model = "Time dependent Cox PH",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$tdcox_model_predictors,collapse="+"))
    
    
    ########################
    ### Adjusted Simple Cox
    ########################
    # --- 2. ROC Calculation (pROC) ---
    what = "Risk_cox_simple"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out6 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Adjusted",
                       model = "Time dependent Cox PH",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$simplecox_model_predictors,collapse="+"))
    
    
    
    
    out <- rbind(out1,out2,out3,out4,out5,out6)
    out
  })
  
  OUT <- do.call("rbind",temp)
  
  save(OUT,file = paste(dir_out,"RESULTS_AUC.RData",sep=""))
  write.csv(OUT,file = paste(dir_out,"RESULTS_AUC.csv",sep=""),row.names = FALSE)
  
}
  


