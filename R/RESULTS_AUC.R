#' Calculate Area Under the Curve (AUC) and Classification Metrics
#'
#' This function systematically calculates the AUC, its confidence intervals,
#' and optimal classification metrics (Sensitivity, Specificity, PPV, NPV)
#' for risk predictions generated by Partly Conditional (PC) and Time-Dependent (TD)
#' Cox models across a user-defined set of clinical endpoints and biomarkers. It
#' performs analyses for both unadjusted and adjusted models, where the adjusted
#' models incorporate a customizable set of covariates.
#'
#' @param dir_in A character string specifying the path to the directory
#'   where the input CSV data files are located. Defaults to a specific network
#'   path. Requires files like \code{cady_data_ct.csv} and \code{baseline_data.csv}.
#' @param dir_out A character string specifying the path to the directory
#'   where the final results (\code{RESULTS_AUC.RData} and \code{RESULTS_AUC.csv})
#'   should be saved. Defaults to a specific network path.
#' @param dat_nam A character vector listing the base names of the data files
#'   representing different clinical endpoint definitions (e.g., \code{c("cady_data_ct", "cady_data_drug", ...)}).
#' @param mar_nam A character vector listing the biomarker names to analyze
#'   (e.g., \code{c("BNP", "NT_pro_BNP", ...)}).
#' @param predictores A character vector specifying the names of the covariates
#'   to be included in the 'Adjusted' models. These variables must be present
#'   in the \code{baseline_data.csv} file. Defaults to a predefined set of six covariates.
#' @param saveopt A character string (optional). If provided, the final aggregated
#'   results data frame (\code{OUT}) will be saved to \code{dir_out} as a CSV and RData
#'   file using this string as the file name prefix. If \code{NULL} (default), no file is saved.
#'   
#' @return A data frame (\code{OUT}) containing the performance metrics for every
#'   combination of data, marker, adjustment type, and model. Columns include:
#' \itemize{
#'   \item \code{marker_name}, \code{data_name}, \code{type}, \code{model}: Identifying information.
#'   \item \code{AUC}: The Area Under the ROC Curve. 
#'   \item \code{LB}, \code{UB}: The 95% Confidence Interval for AUC, corrected for multiple comparisons (Bonferroni).
#'   \item \code{LB_nobon}, \code{UB_nobon}: The uncorrected 95% Confidence Interval for AUC.
#'   \item \code{Threshold_label}: Indicates whether the optimal threshold is given as the raw "Prob"ability or the "Marker" value.
#'   \item \code{Threshold_value}: The calculated optimal threshold value (based on Youden's J).
#'   \item \code{Sensitivity}, \code{Specificity}, \code{PPV} (Positive Predictive Value), \code{NPV} (Negative Predictive Value): Diagnostic metrics at the optimal threshold.
#'   \item \code{PRED}: A string listing the final set of predictors used in the model.
#' }
#'
#' @details
#' The function generates a grid of all combinations of \code{dat_nam} and \code{mar_nam}.
#' For each combination, it loads the data, merges it with baseline covariates, and fits
#' four distinct survival models using \code{\link[cadypredictions]{predict_risk}}:
#'
#' \enumerate{
#'   \item **Unadjusted PC** and **Unadjusted TD Cox**: Biomarker only.
#'   \item **Adjusted PC** and **Adjusted TD Cox**: Biomarker plus the covariates specified in **`predictores`**.
#' }
#'
#' For each of the four models, performance metrics are calculated:
#'
#' * **Multiple Comparison Correction:** A Bonferroni-corrected confidence level ($\text{bc}$) is calculated
#'     based on the total number of models ($|\text{dat\_nam}| \times |\text{mar\_nam}| \times 4$ total tests).
#' * **AUC & CI Calculation:** The Area Under the Curve (AUC) is computed. Confidence intervals (CIs) are calculated
#'     using the **DeLong method** , providing both the Bonferroni-corrected CI (\code{LB}, \code{UB})
#'     and the standard 95\% CI (\code{LB\_nobon}, \code{UB\_nobon}).
#' * **Optimal Threshold & Metrics:** The optimal risk threshold is identified using **Youden's J statistic**
#'     (\code{best.method = "youden"}). At this threshold, Sensitivity, Specificity, PPV, and NPV are extracted.
#' * **Threshold Type:** The optimal threshold is reported either as the predicted **probability** (\code{Prob}) or
#'     the corresponding log-transformed **biomarker value** (\code{Marker}).
#'
#' @import cadypredictions
#' @import tidyverse
#' @import partlyconditional
#' @import survival
#' @import pROC
#' @importFrom base paste read.csv data.frame round
#' @importFrom dplyr select left_join arrange filter slice_tail
#' @importFrom pROC roc ci coords
#'
#' @seealso
#' The model fitting uses \code{\link[cadypredictions]{predict_risk}}.
#' The AUC and classification metrics rely heavily on the \code{pROC} package.
#'
#' @examples
#' \dontrun{
#' # Analyze BNP and CRP for a subset of endpoints, adjusting for only age and LVEF
#' custom_predictors <- c("Age", "lvef_mp_bas")
#' RESULTS_AUC(
#'   dir_in = "C:/data_location/",
#'   dir_out = "C:/results_location/",
#'   dat_nam = c("cady_data_ct", "cady_data_drug"),
#'   mar_nam = c("BNP", "CRP"),
#'   predictores = custom_predictors
#' )
#' # The results will be saved in "C:/results_location/RESULTS_AUC.csv"
#' }
#'
#' @export
#' 
#' 

RESULTS_AUC <- function(dir_in = "M:/CRF/ICORG/Studies/CADY/Clinical_Study_Report/Report/data/",
                    dir_out = "M:/CRF/ICORG/Studies/CADY/Clinical_Study_Report/Report/results/",
                    dat_nam = c("cady_data_ct","cady_data_drug","cady_data_max_50","cady_data_max_53","cady_data_mp_50","cady_data_mp_53"),
                    mar_nam = c("BNP","NT_pro_BNP","CRP","hsTnI_STAT","Galectin_3"),
                    predictores = c("Age","lvef_mp_bas","diabetes_mellitus_YN","hypertension_YN","dyslipidemia_YN","treatment_reg"),
                    saveopt = NULL){
  
  
  library(cadypredictions)
  library(tidyverse)
  library(partlyconditional)
  library(survival)
  library(pROC)
  
  pointer <- expand.grid(data_name = dat_nam,
                         marker_name = mar_nam)
  
  bc <- 1-0.05/(dim(pointer)[1]*4)
  
  
  temp <- lapply(1:dim(pointer)[1],function (kkk){
    #data_name <- "cady_data_mp_50"
    #marker_name = "NT_pro_BNP"
    data_name <- as.character(pointer$data_name[kkk])
    marker_name <- as.character(pointer$marker_name[kkk])
    
    #data_name <- "cady_data_max_50" 
    #marker_name <- "Galectin_3"
    
    cat("\n\n\n",data_name," and ",marker_name,"\n\n")  
    pa <- paste(dir_in,data_name,".csv",sep="")
    
    pa <- paste(dir_in,data_name,".csv",sep="")
    masterD <- read.csv(pa)
    n0 <- "SubjectID"
    n1 <- mar_nam
    n2 <- paste(mar_nam,"_bl",sep="")
    n3 <- c("lvef_mp_bas","lvef_max_bas","time_to_event","status","time_to_sample")
    n4 <- predictores
    wher <- names(masterD) %in% c(n0,n1,n2,n3,n4)
    masterD <- masterD[,wher]
    
    
    bldata <- read.csv(paste(dir_in,"baseline_data.csv",sep=""))
    wher1 <- names(bldata) %in% predictores
    wher2 <- names(bldata) %in% names(masterD)
    wher <- wher1 & !wher2
    bldata <- bldata[,c("SubjectID",names(bldata)[wher])]
    
    masterD <- masterD %>% left_join(bldata,by = "SubjectID")
    
    
    

    
    ###################
    ### Unadjusted PC
    ###################
    fit <- predict_risk(
      datos = masterD,
      marker_name = marker_name,
      log_marker = TRUE,
      pred_from = 150,
      pred_to = 240
    )
    
    df <- as.data.frame(fit$pred_data)
    
    # --- 2. ROC Calculation (pROC) ---
    what <- "Risk_PC"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out1 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Unadjusted",
                       model = "Partly conditional",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$pc_model_predictors,collapse="+"))
    
    
    ###################
    ### Unadjusted TD
    ###################
    df <- as.data.frame(fit$pred_data)
    
    # --- 2. ROC Calculation (pROC) ---
    what <- "Risk_TDcox"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out2 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Unadjusted",
                       model = "Time dependent Cox PH",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$tdcox_model_predictors,collapse="+"))
    
    
    ##########################
    ### Unadjusted Simple Cox
    ##########################
    df <- as.data.frame(fit$pred_data)
    
    # --- 2. ROC Calculation (pROC) ---
    what <- "Risk_cox_simple"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out3 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Unadjusted",
                       model = "Simple Cox PH",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$simplecox_model_predictors,collapse="+"))
    
    
    ################
    ### Adjusted PC
    ################
    fit <- predict_risk(
      datos = masterD,
      marker_name = marker_name,
      Predictors = predictores,
      log_marker = TRUE,
      pred_from = 150,
      pred_to = 240
    )
    pc_model_predictors<-fit$pc_model_predictors
    tdcox_model_predictors <- fit$tdcox_model_predictors
    simplecox_model_predictors <- fit$simplecox_model_predictors
    
    
    df <- as.data.frame(fit$pred_data)
    
    # --- 2. ROC Calculation (pROC) ---
    what = "Risk_PC"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out4 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Adjusted",
                       model = "Partly conditional",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$pc_model_predictors,collapse="+"))
    
    
    ###################
    ### Adjusted TD
    ###################
    # --- 2. ROC Calculation (pROC) ---
    what = "Risk_TDcox"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out5 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Adjusted",
                       model = "Time dependent Cox PH",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$tdcox_model_predictors,collapse="+"))
    
    
    ########################
    ### Adjusted Simple Cox
    ########################
    # --- 2. ROC Calculation (pROC) ---
    what = "Risk_cox_simple"
    roc_obj <- roc(df$status, df[, what], algorithm = 1, quiet = TRUE)
    
    # Calculate AUC and CI
    ci_delong <- ci(roc_obj, method = "delong",conf.level=bc)
    ci_delong_nobon <- ci(roc_obj, method = "delong",conf.level=0.95)
    
    auc <- round(ci_delong[2], 3)
    lb <- round(ci_delong[1], 3)
    ub <- round(ci_delong[3], 3)
    lb_nobon <- round(ci_delong_nobon[1], 3)
    ub_nobon <- round(ci_delong_nobon[3], 3)
    
    # --- 3. Optimal Threshold Calculation (Youden's J) ---
    optimal_coords <- coords(roc_obj, x = "best", best.method = "youden",
                             ret = c("threshold", "specificity", "sensitivity", "ppv", "npv"))
    if (dim(optimal_coords)[1]>1) {
      optimal_coords <- optimal_coords %>% arrange(threshold) %>% slice(1)
    }
    
    
    sen <- round(optimal_coords$sensitivity,3)
    spe <- round(optimal_coords$specificity,3)
    ppv <- round(optimal_coords$ppv,3)
    npv <- round(optimal_coords$npv,3)
    
    
    # Conditional Optimal Threshold Label Logic
    df$dup <- df[, what]
    temp1 <- order(df$marker1)
    temp2 <- order(df$dup)
    if (all(temp1 == temp2)) {
      # If ordering is the same, use the marker value
      df1 <- df %>% 
        arrange(dup) %>% 
        filter(dup <= optimal_coords$threshold) %>% 
        slice_tail(n = 1)
      threshold_label <- "Marker"
      threshold_value <- round(df1$marker1, 1)
    } else {
      # If ordering is different, use the raw probability threshold
      threshold_label <-"Prob" 
      threshold_value <- round(optimal_coords$threshold, 3)
    }
    
    out6 <- data.frame(marker_name=marker_name,
                       data_name=data_name,
                       type = "Adjusted",
                       model = "Time dependent Cox PH",
                       AUC = auc,
                       LB = lb,
                       UB = ub,
                       LB_nobon = lb_nobon,
                       UB_nobon = ub_nobon,
                       Threshold_label = threshold_label,
                       Threshold_value = threshold_value,
                       Sensitivity = sen,
                       Specificity = spe,
                       PPV = ppv,
                       NPV = npv,
                       PRED = paste(fit$simplecox_model_predictors,collapse="+"))
    
    
    
    
    out <- rbind(out1,out2,out3,out4,out5,out6)
    out
  })
  
  OUT <- do.call("rbind",temp)
  
  if (!is.null(saveopt)) {
    save(OUT,file = paste(dir_out,saveopt,".RData",sep="") )
    write.csv(OUT,file = paste(dir_out,,saveopt,".csv",sep=""),row.names = FALSE)
  }
  
  OUT
  
  
}
  


